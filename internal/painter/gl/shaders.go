// auto-generated
// Code generated by '$ fyne bundle'. DO NOT EDIT.

package gl

import "fyne.io/fyne/v2"

// single
var shaderLineFrag = &fyne.StaticResource{
	StaticName: "line.frag",
	StaticContent: []byte(
		"#version 110\n\nuniform vec4 color;\nuniform float lineWidth;\nuniform float feather;\n\nvarying vec2 delta;\n\nvoid main() {\n    float alpha = color.a;\n    float distance = length(delta);\n\n    if (feather == 0.0 || distance <= lineWidth - feather) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(color.r, color.g, color.b, mix(color.a, 0.0, (distance - (lineWidth - feather)) / feather));\n    }\n}\n"),
}
var shaderLineVert = &fyne.StaticResource{
	StaticName: "line.vert",
	StaticContent: []byte(
		"#version 110\n\nattribute vec2 vert;\nattribute vec2 normal;\n    \nuniform float lineWidth;\n\nvarying vec2 delta;\n\nvoid main() {\n    delta = normal * lineWidth;\n\n    gl_Position = vec4(vert + delta, 0, 1);\n}\n"),
}
var shaderLineesFrag = &fyne.StaticResource{
	StaticName: "line_es.frag",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\nuniform vec4 color;\nuniform float lineWidth;\nuniform float feather;\n\nvarying vec2 delta;\n\nvoid main() {\n    float alpha = color.a;\n    float distance = length(delta);\n\n    if (feather == 0.0 || distance <= lineWidth - feather) {\n        gl_FragColor = color;\n    } else {\n        gl_FragColor = vec4(color.r, color.g, color.b, mix(color.a, 0.0, (distance - (lineWidth - feather)) / feather));\n    }\n}\n"),
}
var shaderLineesVert = &fyne.StaticResource{
	StaticName: "line_es.vert",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\nattribute vec2 vert;\nattribute vec2 normal;\n    \nuniform float lineWidth;\n\nvarying vec2 delta;\n\nvoid main() {\n    delta = normal * lineWidth;\n\n    gl_Position = vec4(vert + delta, 0, 1);\n}\n"),
}
var shaderRectangleFrag = &fyne.StaticResource{
	StaticName: "rectangle.frag",
	StaticContent: []byte(
		"#version 110\n\n/* scaled params */\nuniform vec2 frame_size;\nuniform vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\nuniform float stroke_width;\n/* colors params*/\nuniform vec4 fill_color;\nuniform vec4 stroke_color;\n\n\nvoid main() {\n\n    vec4 color = fill_color;\n    \n    if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\n        color = stroke_color;\n    } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\n        color = stroke_color;\n    } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\n        color = stroke_color;\n    } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\n        color = stroke_color;\n    }\n\n    gl_FragColor = color;\n}\n"),
}
var shaderRectangleVert = &fyne.StaticResource{
	StaticName: "rectangle.vert",
	StaticContent: []byte(
		"#version 110\n\nattribute vec2 vert;\nattribute vec2 normal;\n\nvoid main() {\n    gl_Position = vec4(vert+normal, 0, 1);\n}\n"),
}
var shaderRectangleesFrag = &fyne.StaticResource{
	StaticName: "rectangle_es.frag",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\n/* scaled params */\nuniform vec2 frame_size;\nuniform vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\nuniform float stroke_width;\n/* colors params*/\nuniform vec4 fill_color;\nuniform vec4 stroke_color;\n\n\nvoid main() {\n\n    vec4 color = fill_color;\n    \n    if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\n        color = stroke_color;\n    } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\n        color = stroke_color;\n    } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\n        color = stroke_color;\n    } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\n        color = stroke_color;\n    }\n\n    gl_FragColor = color;\n}\n"),
}
var shaderRectangleesVert = &fyne.StaticResource{
	StaticName: "rectangle_es.vert",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\nattribute vec2 vert;\nattribute vec2 normal;\n\nvoid main() {\n    gl_Position = vec4(vert+normal, 0, 1);\n}\n"),
}
var shaderRoundrectangleFrag = &fyne.StaticResource{
	StaticName: "round_rectangle.frag",
	StaticContent: []byte(
		"#version 110\n\n/* scaled params */\nuniform vec2 frame_size;\nuniform vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\nuniform float stroke_width_half;\nuniform vec2 rect_size_half;\nuniform float radius;\n/* colors params*/\nuniform vec4 fill_color;\nuniform vec4 stroke_color;\n\nfloat calc_distance(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b + vec2(r);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nvoid main() {\n\n    vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\n    vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\n\n    float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\n\n    vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\n    vec4 to_color = stroke_color; //Outside color\n\n    if (stroke_width_half == 0.0)\n    {\n        from_color = fill_color;\n        to_color = fill_color;\n    }\n    to_color[3] = 0.0; // blend the fill colour to alpha\n\n    if (distance < 0.0)\n    {\n        to_color = fill_color;\n    } \n\n    distance = abs(distance) - stroke_width_half;\n\n    float blend_amount = smoothstep(-1.0, 1.0, distance);\n\n    // final color\n    gl_FragColor = mix(from_color, to_color, blend_amount);\n}\n"),
}
var shaderRoundrectangleesFrag = &fyne.StaticResource{
	StaticName: "round_rectangle_es.frag",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\n/* scaled params */\nuniform vec2 frame_size;\nuniform vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\nuniform float stroke_width_half;\nuniform vec2 rect_size_half;\nuniform float radius;\n/* colors params*/\nuniform vec4 fill_color;\nuniform vec4 stroke_color;\n\nfloat calc_distance(vec2 p, vec2 b, float r)\n{\n    vec2 d = abs(p) - b + vec2(r);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nvoid main() {\n\n    vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\n    vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\n\n    float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\n\n    vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\n    vec4 to_color = stroke_color; //Outside color\n\n    if (stroke_width_half == 0.0)\n    {\n        from_color = fill_color;\n        to_color = fill_color;\n    }\n    to_color[3] = 0.0; // blend the fill colour to alpha\n\n    if (distance < 0.0)\n    {\n        to_color = fill_color;\n    } \n\n    distance = abs(distance) - stroke_width_half;\n\n    float blend_amount = smoothstep(-1.0, 1.0, distance);\n\n    // final color\n    gl_FragColor = mix(from_color, to_color, blend_amount);\n}\n"),
}
var shaderSimpleFrag = &fyne.StaticResource{
	StaticName: "simple.frag",
	StaticContent: []byte(
		"#version 110\n\nuniform sampler2D tex;\n\nvarying vec2 fragTexCoord;\n\nvoid main() {\n    gl_FragColor = texture2D(tex, fragTexCoord);\n}\n"),
}
var shaderSimpleVert = &fyne.StaticResource{
	StaticName: "simple.vert",
	StaticContent: []byte(
		"#version 110\n\nattribute vec3 vert;\nattribute vec2 vertTexCoord;\nvarying vec2 fragTexCoord;\n\nvoid main() {\n    fragTexCoord = vertTexCoord;\n\n    gl_Position = vec4(vert, 1);\n}"),
}
var shaderSimpleesFrag = &fyne.StaticResource{
	StaticName: "simple_es.frag",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\nuniform sampler2D tex;\n\nvarying vec2 fragTexCoord;\n\nvoid main() {\n    gl_FragColor = texture2D(tex, fragTexCoord);\n}\n"),
}
var shaderSimpleesVert = &fyne.StaticResource{
	StaticName: "simple_es.vert",
	StaticContent: []byte(
		"#version 100\n\n#ifdef GL_ES\n# ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n# else\nprecision mediump float;\n#endif\nprecision mediump int;\nprecision lowp sampler2D;\n#endif\n\nattribute vec3 vert;\nattribute vec2 vertTexCoord;\nvarying vec2 fragTexCoord;\n\nvoid main() {\n    fragTexCoord = vertTexCoord;\n\n    gl_Position = vec4(vert, 1);\n}"),
}

// multi
var shaderMultiVert = &fyne.StaticResource{
	StaticName: "multi.vert",
	StaticContent: []byte(
		"#version 110\r\n\r\n/* scaled */\r\nuniform vec2 frame_size; //window_size\r\n\r\n/* triangle 6 points (x | y) for rect */\r\nattribute vec2 att_vert;\r\n\r\n/* \r\nscaled size, coords \r\nDescription of the new shape.\r\n*/\r\n// (shape = 1.0, 2.0 | stroke_width | radius    | NOT_USED )\r\n// (shape = 3.0      | texture x    | texture y | texIdx )\r\nattribute vec4 att_type; \r\n\r\n/*\r\nShapes:\r\n1.0 = rectangle\r\n2.0 = round_rectangle\r\n3.0 = text texture\r\n*/\r\n\r\nattribute vec4 att_fill_color; // (fillColor RGBA)\r\nattribute vec4 att_stroke_color; // (fillColor RGBA)\r\nattribute vec4 att_rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\n\r\nvarying float type;\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4  fill_color;\r\nvarying vec4  stroke_color;\r\n\r\nvarying vec4  rect_coords;\r\nvarying vec2  rect_size_half;\r\n\r\n// for Texture\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n/*\r\nvec4 unpack_to_frag_color(float rgb_as_float, float a){\r\n    vec4 color;\r\n    color.b = floor(rgb_as_float / 256.0 / 256.0);\r\n    color.g = floor((rgb_as_float - color.r * 256.0 * 256.0) / 256.0);\r\n    color.r = floor(rgb_as_float - color.r * 256.0 * 256.0 - color.g * 256.0);\r\n    color.a = a;\r\n    return color / 256.0;\r\n}\r\n*/\r\n\r\nvec2 get_rect_size_half(vec4 rect_coords, float stroke_width){\r\n    vec2 rect_size_half;\r\n    float rect_size_width  = rect_coords[1] - rect_coords[0] - stroke_width;\r\n    float rect_size_height = rect_coords[3] - rect_coords[2] - stroke_width;\r\n    rect_size_half = vec2(rect_size_width*0.5, rect_size_height*0.5);\r\n    return rect_size_half;\r\n}\r\n\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    type = att_type[0];\r\n\r\n    if (type == 1.0 || type == 2.0){\r\n        stroke_width = att_type[1];\r\n        stroke_width_half = stroke_width * 0.5;\r\n        radius = att_type[2];\r\n        fill_color = att_fill_color;\r\n        if (stroke_width != 0.0){       \r\n            stroke_color = att_stroke_color;\r\n        }\r\n        rect_coords = att_rect_coords;\r\n        if (type == 2.0){\r\n            rect_size_half = get_rect_size_half(rect_coords, stroke_width);\r\n        }\r\n    } else if (type == 3.0){\r\n        fragTexCoord.x = att_type[1];\r\n        fragTexCoord.y = att_type[2];\r\n        texIdx = att_type[3];\r\n    }\r\n\r\n}\r\n\r\n\r\n"),
}
var shaderMultiFrag = &fyne.StaticResource{
	StaticName: "multi.frag",
	StaticContent: []byte(
		"#version 110\r\n\r\n/* scaled */\r\nuniform vec2 frame_size;\r\n\r\nvarying float type;\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4 fill_color;\r\nvarying vec4 stroke_color;\r\n\r\nvarying vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\nvarying vec2 rect_size_half;\r\n\r\n// for Texture\r\nuniform sampler2D textures[32];\r\n/*\r\nuniform sampler2D texture0;\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nuniform sampler2D texture3;\r\n*/\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n\r\nfloat calc_distance(vec2 p, vec2 b, float r)\r\n{\r\n    vec2 d = abs(p) - b + vec2(r);\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \r\n}\r\n\r\nvoid main() {\r\n\r\n    if (type == 1.0) {\r\n        vec4 color = fill_color;\r\n        if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\r\n            color = stroke_color;\r\n        }\r\n        gl_FragColor = color; \r\n          \r\n    } else if (type == 2.0 ) {\r\n        vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\r\n        vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\r\n\r\n        float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\r\n\r\n        vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\r\n        vec4 to_color = stroke_color; //Outside color\r\n\r\n        if (stroke_width_half == 0.0)\r\n        {\r\n            from_color = fill_color;\r\n            to_color = fill_color;\r\n        }\r\n        to_color[3] = 0.0; // blend the fill colour to alpha\r\n\r\n        if (distance < 0.0)\r\n        {\r\n            to_color = fill_color;\r\n        } \r\n\r\n        distance = abs(distance) - stroke_width_half;\r\n\r\n        float blend_amount = smoothstep(-1.0, 1.0, distance);\r\n\r\n        // final color\r\n        gl_FragColor = mix(from_color, to_color, blend_amount);\r\n\r\n    } else if (type == 3.0 ) {\r\n        int idx = int(texIdx);\r\n        gl_FragColor = texture2D(textures[idx], fragTexCoord);\r\n        /* debug\r\n        if (idx == 0){\r\n            //gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\r\n            gl_FragColor = texture2D(texture0, fragTexCoord);\r\n        } else if (idx == 1){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(texture1, fragTexCoord);\r\n        } else if (idx == 2){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(texture2, fragTexCoord);\r\n        } else if (idx == 3){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(texture3, fragTexCoord);\r\n        }\r\n        */\r\n\r\n    }\r\n}\r\n"),
}
var shaderMultiesVert = &fyne.StaticResource{
	StaticName: "multi_es.vert",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/* scaled */\r\nuniform vec2 frame_size; //window_size\r\n\r\n/* triangle 6 points (x | y) for rect */\r\nattribute vec2 att_vert;\r\n\r\n/* \r\nscaled size, coords \r\nDescription of the new shape.\r\n*/\r\n// (shape = 1.0, 2.0 | stroke_width | radius    | NOT_USED )\r\n// (shape = 3.0      | texture x    | texture y | texIdx )\r\nattribute vec4 att_type; \r\n\r\n/*\r\nShapes:\r\n1.0 = rectangle\r\n2.0 = round_rectangle\r\n3.0 = text texture\r\n*/\r\n\r\nattribute vec4 att_fill_color; // (fillColor RGBA)\r\nattribute vec4 att_stroke_color; // (fillColor RGBA)\r\nattribute vec4 att_rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\n\r\nvarying float type;\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4  fill_color;\r\nvarying vec4  stroke_color;\r\n\r\nvarying vec4  rect_coords;\r\nvarying vec2  rect_size_half;\r\n\r\n// for Texture\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n/*\r\nvec4 unpack_to_frag_color(float rgb_as_float, float a){\r\n    vec4 color;\r\n    color.b = floor(rgb_as_float / 256.0 / 256.0);\r\n    color.g = floor((rgb_as_float - color.r * 256.0 * 256.0) / 256.0);\r\n    color.r = floor(rgb_as_float - color.r * 256.0 * 256.0 - color.g * 256.0);\r\n    color.a = a;\r\n    return color / 256.0;\r\n}\r\n*/\r\n\r\nvec2 get_rect_size_half(vec4 rect_coords, float stroke_width){\r\n    vec2 rect_size_half;\r\n    float rect_size_width  = rect_coords[1] - rect_coords[0] - stroke_width;\r\n    float rect_size_height = rect_coords[3] - rect_coords[2] - stroke_width;\r\n    rect_size_half = vec2(rect_size_width*0.5, rect_size_height*0.5);\r\n    return rect_size_half;\r\n}\r\n\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    type = att_type[0];\r\n\r\n    if (type == 1.0 || type == 2.0){\r\n        stroke_width = att_type[1];\r\n        stroke_width_half = stroke_width * 0.5;\r\n        radius = att_type[2];\r\n        fill_color = att_fill_color;\r\n        if (stroke_width != 0.0){       \r\n            stroke_color = att_stroke_color;\r\n        }\r\n        rect_coords = att_rect_coords;\r\n        if (type == 2.0){\r\n            rect_size_half = get_rect_size_half(rect_coords, stroke_width);\r\n        }\r\n    } else if (type == 3.0){\r\n        fragTexCoord.x = att_type[1];\r\n        fragTexCoord.y = att_type[2];\r\n        texIdx = att_type[3];\r\n    }\r\n\r\n}\r\n\r\n\r\n"),
}
var shaderMultiesFrag = &fyne.StaticResource{
	StaticName: "multi_es.frag",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/* scaled */\r\nuniform vec2 frame_size;\r\n\r\nvarying float type;\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4 fill_color;\r\nvarying vec4 stroke_color;\r\n\r\nvarying vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\nvarying vec2 rect_size_half;\r\n\r\n// for Texture\r\nuniform sampler2D textures[16];\r\n/*\r\nuniform sampler2D texture0;\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nuniform sampler2D texture3;\r\n*/\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n\r\nfloat calc_distance(vec2 p, vec2 b, float r)\r\n{\r\n    vec2 d = abs(p) - b + vec2(r);\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \r\n}\r\n\r\nvoid main() {\r\n\r\n    if (type == 1.0) {\r\n        vec4 color = fill_color;\r\n        if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\r\n            color = stroke_color;\r\n        }\r\n        gl_FragColor = color; \r\n          \r\n    } else if (type == 2.0 ) {\r\n        vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\r\n        vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\r\n\r\n        float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\r\n\r\n        vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\r\n        vec4 to_color = stroke_color; //Outside color\r\n\r\n        if (stroke_width_half == 0.0)\r\n        {\r\n            from_color = fill_color;\r\n            to_color = fill_color;\r\n        }\r\n        to_color[3] = 0.0; // blend the fill colour to alpha\r\n\r\n        if (distance < 0.0)\r\n        {\r\n            to_color = fill_color;\r\n        } \r\n\r\n        distance = abs(distance) - stroke_width_half;\r\n\r\n        float blend_amount = smoothstep(-1.0, 1.0, distance);\r\n\r\n        // final color\r\n        gl_FragColor = mix(from_color, to_color, blend_amount);\r\n\r\n    } else if (type == 3.0 ) {\r\n        int idx = int(texIdx);\r\n        //not in GL_ES: gl_FragColor = texture2D(textures[idx], fragTexCoord);\r\n        if (idx == 0){\r\n            //gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\r\n            gl_FragColor = texture2D(textures[0], fragTexCoord);\r\n        } else if (idx == 1){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(textures[1], fragTexCoord);\r\n        } else if (idx == 2){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[2], fragTexCoord);\r\n        } else if (idx == 3){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[3], fragTexCoord);\r\n        } else if (idx == 4){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(textures[4], fragTexCoord);\r\n        } else if (idx == 5){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[5], fragTexCoord);\r\n        } else if (idx == 6){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[6], fragTexCoord);\r\n        } else if (idx == 7){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(textures[7], fragTexCoord);\r\n        } else if (idx == 8){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[8], fragTexCoord);\r\n        } else if (idx == 9){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[9], fragTexCoord);\r\n        } else if (idx == 10){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(textures[10], fragTexCoord);\r\n        } else if (idx == 11){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[11], fragTexCoord);\r\n        } else if (idx == 12){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[12], fragTexCoord);\r\n        } else if (idx == 13){\r\n            //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n             gl_FragColor = texture2D(textures[13], fragTexCoord);\r\n        } else if (idx == 14){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[14], fragTexCoord);\r\n        } else if (idx == 15){\r\n            //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n             gl_FragColor = texture2D(textures[15], fragTexCoord);\r\n        }\r\n\r\n    }\r\n}\r\n"),
}

// group
var shaderGroupRoundrectangleVert = &fyne.StaticResource{
	StaticName: "group_round_rectangle.vert",
	StaticContent: []byte(
		"#version 110\r\n\r\n/** scaled size and coords **/\r\n\r\nuniform vec2 frame_size; //window_size\r\n\r\n// triangle 6 points ( x | y ) for rect\r\nattribute vec2 att_vert;\r\nattribute vec2 att_type;         // ( stroke_width | radius ) \r\nattribute vec4 att_fill_color;   // (fillColor RGBA)\r\nattribute vec4 att_stroke_color; // (strokeColor RGBA)\r\nattribute vec4 att_rect_coords;  // x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\n// ----- attributes size = 16 -----\r\n\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4  fill_color;\r\nvarying vec4  stroke_color;\r\n\r\nvarying vec4  rect_coords;\r\nvarying vec2  rect_size_half;\r\n\r\n\r\nvec2 get_rect_size_half(vec4 rect_coords, float stroke_width){\r\n    vec2 rect_size_half;\r\n    float rect_size_width  = rect_coords[1] - rect_coords[0] - stroke_width;\r\n    float rect_size_height = rect_coords[3] - rect_coords[2] - stroke_width;\r\n    rect_size_half = vec2(rect_size_width*0.5, rect_size_height*0.5);\r\n    return rect_size_half;\r\n}\r\n\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    stroke_width = att_type[0];\r\n    stroke_width_half = stroke_width * 0.5;\r\n    radius = att_type[1];\r\n    fill_color = att_fill_color;\r\n    if (stroke_width != 0.0){       \r\n        stroke_color = att_stroke_color;\r\n    }\r\n    rect_coords = att_rect_coords;\r\n    if (radius > 0.0){\r\n        rect_size_half = get_rect_size_half(rect_coords, stroke_width);\r\n    }\r\n}\r\n\r\n\r\n"),
}
var shaderGroupRoundrectangleFrag = &fyne.StaticResource{
	StaticName: "group_round_rectangle.frag",
	StaticContent: []byte(
		"#version 110\r\n\r\n/* scaled */\r\nuniform vec2 frame_size;\r\n\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4 fill_color;\r\nvarying vec4 stroke_color;\r\n\r\nvarying vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\nvarying vec2 rect_size_half;\r\n\r\n\r\nfloat calc_distance(vec2 p, vec2 b, float r)\r\n{\r\n    vec2 d = abs(p) - b + vec2(r);\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \r\n}\r\n\r\nvoid main() {\r\n\r\n    if (radius == 0.0) {\r\n        vec4 color = fill_color;\r\n        if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\r\n            color = stroke_color;\r\n        }\r\n        gl_FragColor = color; \r\n          \r\n    } else {\r\n        vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\r\n        vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\r\n\r\n        float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\r\n\r\n        vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\r\n        vec4 to_color = stroke_color; //Outside color\r\n\r\n        if (stroke_width_half == 0.0)\r\n        {\r\n            from_color = fill_color;\r\n            to_color = fill_color;\r\n        }\r\n        to_color[3] = 0.0; // blend the fill colour to alpha\r\n\r\n        if (distance < 0.0)\r\n        {\r\n            to_color = fill_color;\r\n        } \r\n\r\n        distance = abs(distance) - stroke_width_half;\r\n\r\n        float blend_amount = smoothstep(-1.0, 1.0, distance);\r\n\r\n        // final color\r\n        gl_FragColor = mix(from_color, to_color, blend_amount);\r\n\r\n    } \r\n}\r\n"),
}
var shaderGroupTextureVert = &fyne.StaticResource{
	StaticName: "group_texture.vert",
	StaticContent: []byte(
		"#version 110\r\n\r\n/** scaled **/\r\nuniform vec2 frame_size; //window_size\r\n\r\n// triangle 6 points (x | y) for rect\r\nattribute vec2 att_vert;\r\nattribute vec4 att_type;    // (texture x | texture y | texIdx | UNUSED )\r\n// ----- attributes size = 6 ----- \r\n\r\n// for Texture\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    fragTexCoord.x = att_type[0];\r\n    fragTexCoord.y = att_type[1];\r\n    texIdx = att_type[2];\r\n}\r\n\r\n\r\n"),
}
var shaderGroupTextureFrag = &fyne.StaticResource{
	StaticName: "group_texture.frag",
	StaticContent: []byte(
		"#version 110\r\n\r\n/* scaled */\r\n// uniform vec2 frame_size; //window_size not used here\r\n\r\n// for Texture\r\nuniform sampler2D textures[32];\r\n/*\r\nuniform sampler2D texture0;\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nuniform sampler2D texture3;\r\n*/\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n\r\nvoid main() {\r\n    int idx = int(texIdx);\r\n    gl_FragColor = texture2D(textures[idx], fragTexCoord);\r\n\r\n    /* debug\r\n    if (idx == 0){\r\n        //gl_FragColor = vec4(1.0, 0.5, 0.0, 1.0);\r\n        gl_FragColor = texture2D(texture0, fragTexCoord);\r\n    } else if (idx == 1){\r\n        //gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\r\n         gl_FragColor = texture2D(texture1, fragTexCoord);\r\n    } else if (idx == 2){\r\n        //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n         gl_FragColor = texture2D(texture2, fragTexCoord);\r\n    } else if (idx == 3){\r\n        //gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n         gl_FragColor = texture2D(texture3, fragTexCoord);\r\n    }\r\n    */\r\n\r\n}\r\n"),
}
var shaderGroupRoundrectangleesVert = &fyne.StaticResource{
	StaticName: "group_round_rectangle_es.vert",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/** scaled size and coords **/\r\n\r\nuniform vec2 frame_size; //window_size\r\n\r\n// triangle 6 points ( x | y ) for rect\r\nattribute vec2 att_vert;\r\nattribute vec2 att_type;         // ( stroke_width | radius ) \r\nattribute vec4 att_fill_color;   // (fillColor RGBA)\r\nattribute vec4 att_stroke_color; // (strokeColor RGBA)\r\nattribute vec4 att_rect_coords;  // x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\n// ----- attributes size = 16 -----\r\n\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4  fill_color;\r\nvarying vec4  stroke_color;\r\n\r\nvarying vec4  rect_coords;\r\nvarying vec2  rect_size_half;\r\n\r\n\r\nvec2 get_rect_size_half(vec4 rect_coords, float stroke_width){\r\n    vec2 rect_size_half;\r\n    float rect_size_width  = rect_coords[1] - rect_coords[0] - stroke_width;\r\n    float rect_size_height = rect_coords[3] - rect_coords[2] - stroke_width;\r\n    rect_size_half = vec2(rect_size_width*0.5, rect_size_height*0.5);\r\n    return rect_size_half;\r\n}\r\n\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    stroke_width = att_type[0];\r\n    stroke_width_half = stroke_width * 0.5;\r\n    radius = att_type[1];\r\n    fill_color = att_fill_color;\r\n    if (stroke_width != 0.0){       \r\n        stroke_color = att_stroke_color;\r\n    }\r\n    rect_coords = att_rect_coords;\r\n    if (radius > 0.0){\r\n        rect_size_half = get_rect_size_half(rect_coords, stroke_width);\r\n    }\r\n}\r\n\r\n\r\n"),
}
var shaderGroupRoundrectangleesFrag = &fyne.StaticResource{
	StaticName: "group_round_rectangle_es.frag",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/* scaled */\r\nuniform vec2 frame_size;\r\n\r\nvarying float stroke_width;\r\nvarying float stroke_width_half;\r\nvarying float radius;\r\n\r\nvarying vec4 fill_color;\r\nvarying vec4 stroke_color;\r\n\r\nvarying vec4 rect_coords; //x1 [0], x2 [1], y1 [2], y2 [3]; coords of the rect_frame\r\nvarying vec2 rect_size_half;\r\n\r\n\r\nfloat calc_distance(vec2 p, vec2 b, float r)\r\n{\r\n    vec2 d = abs(p) - b + vec2(r);\r\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \r\n}\r\n\r\nvoid main() {\r\n\r\n    if (radius == 0.0) {\r\n        vec4 color = fill_color;\r\n        if (gl_FragCoord.x >= rect_coords[1] - stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.x <= rect_coords[0] + stroke_width){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y <= frame_size.y - rect_coords[3] + stroke_width ){\r\n            color = stroke_color;\r\n        } else if (gl_FragCoord.y >= frame_size.y - rect_coords[2] - stroke_width ){\r\n            color = stroke_color;\r\n        }\r\n        gl_FragColor = color; \r\n          \r\n    } else {\r\n        vec4 frag_rect_coords = vec4(rect_coords[0], rect_coords[1], frame_size.y - rect_coords[3], frame_size.y - rect_coords[2]);\r\n        vec2 vec_centered_pos = (gl_FragCoord.xy - vec2(frag_rect_coords[0] + frag_rect_coords[1], frag_rect_coords[2] + frag_rect_coords[3]) * 0.5);\r\n\r\n        float distance = calc_distance(vec_centered_pos, rect_size_half, radius - stroke_width_half);\r\n\r\n        vec4 from_color = stroke_color; //Always the border color. If no border, this still should be set\r\n        vec4 to_color = stroke_color; //Outside color\r\n\r\n        if (stroke_width_half == 0.0)\r\n        {\r\n            from_color = fill_color;\r\n            to_color = fill_color;\r\n        }\r\n        to_color[3] = 0.0; // blend the fill colour to alpha\r\n\r\n        if (distance < 0.0)\r\n        {\r\n            to_color = fill_color;\r\n        } \r\n\r\n        distance = abs(distance) - stroke_width_half;\r\n\r\n        float blend_amount = smoothstep(-1.0, 1.0, distance);\r\n\r\n        // final color\r\n        gl_FragColor = mix(from_color, to_color, blend_amount);\r\n\r\n    } \r\n}\r\n"),
}
var shaderGroupTextureesVert = &fyne.StaticResource{
	StaticName: "group_texture_es.vert",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/** scaled **/\r\nuniform vec2 frame_size; //window_size\r\n\r\n// triangle 6 points (x | y) for rect\r\nattribute vec2 att_vert;\r\nattribute vec4 att_type;    // (texture x | texture y | texIdx | UNUSED )\r\n// ----- attributes size = 6 ----- \r\n\r\n// for Texture\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\nvoid main() {\r\n    // normalize att_vert in GPU\r\n    gl_Position = vec4(-1.0 + att_vert.x*2.0/frame_size.x, 1.0 - att_vert.y*2.0/frame_size.y, 0, 1);\r\n\r\n    fragTexCoord.x = att_type[0];\r\n    fragTexCoord.y = att_type[1];\r\n    texIdx = att_type[2];\r\n}\r\n\r\n\r\n"),
}
var shaderGroupTextureesFrag = &fyne.StaticResource{
	StaticName: "group_texture_es.frag",
	StaticContent: []byte(
		"#version 100\r\n\r\n#ifdef GL_ES\r\n# ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n# else\r\nprecision mediump float;\r\n#endif\r\nprecision mediump int;\r\nprecision lowp sampler2D;\r\n#endif\r\n\r\n/* scaled */\r\n// uniform vec2 frame_size; //window_size not used here\r\n\r\n// for Texture\r\nuniform sampler2D textures[16];\r\n/*\r\nuniform sampler2D texture0;\r\nuniform sampler2D texture1;\r\nuniform sampler2D texture2;\r\nuniform sampler2D texture3;\r\n*/\r\nvarying vec2 fragTexCoord;\r\nvarying float texIdx;\r\n\r\n\r\nvoid main() {\r\n    int idx = int(texIdx);\r\n    //not in GL_ES: gl_FragColor = texture2D(textures[idx], fragTexCoord);\r\n    if (idx == 0){\r\n        gl_FragColor = texture2D(textures[0], fragTexCoord);\r\n    } else if (idx == 1){\r\n            gl_FragColor = texture2D(textures[1], fragTexCoord);\r\n    } else if (idx == 2){\r\n            gl_FragColor = texture2D(textures[2], fragTexCoord);\r\n    } else if (idx == 3){\r\n            gl_FragColor = texture2D(textures[3], fragTexCoord);\r\n    } else if (idx == 4){\r\n            gl_FragColor = texture2D(textures[4], fragTexCoord);\r\n    } else if (idx == 5){\r\n            gl_FragColor = texture2D(textures[5], fragTexCoord);\r\n    } else if (idx == 6){\r\n            gl_FragColor = texture2D(textures[6], fragTexCoord);\r\n    } else if (idx == 7){\r\n            gl_FragColor = texture2D(textures[7], fragTexCoord);\r\n    } else if (idx == 8){\r\n            gl_FragColor = texture2D(textures[8], fragTexCoord);\r\n    } else if (idx == 9){\r\n            gl_FragColor = texture2D(textures[9], fragTexCoord);\r\n    } else if (idx == 10){\r\n            gl_FragColor = texture2D(textures[10], fragTexCoord);\r\n    } else if (idx == 11){\r\n            gl_FragColor = texture2D(textures[11], fragTexCoord);\r\n    } else if (idx == 12){\r\n            gl_FragColor = texture2D(textures[12], fragTexCoord);\r\n    } else if (idx == 13){\r\n            gl_FragColor = texture2D(textures[13], fragTexCoord);\r\n    } else if (idx == 14){\r\n            gl_FragColor = texture2D(textures[14], fragTexCoord);\r\n    } else if (idx == 15){\r\n            gl_FragColor = texture2D(textures[15], fragTexCoord);\r\n    }\r\n\r\n}\r\n"),
}